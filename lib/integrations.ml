open Core
open Project

let get_resource_headers ~out_dir resources =
  List.map resources ~f:(fun res_path ->
      let filename = Filename.basename res_path in
      sprintf "%s/%s.h" out_dir
        (sprintf "%s_%s" (Util.hash_path res_path) filename))
  |> Array.of_list

module Clangd = struct
  let to_compile_flags_txt ~(config : Project_config.t) (project : avr_project)
      =
    let module C = Compiler_args in
    let target =
      let open Project_config in
      let convert_mcu mcu =
        let pat = Re.compile @@ Re.Pcre.re {|(\d+\w*)+$|} in
        let match' = List.hd_exn @@ Re.matches pat mcu in

        String.lowercase mcu
        |> String.substr_replace_first ~pattern:"at" ~with_:"AT"
        |> String.substr_replace_first ~pattern:match'
             ~with_:(String.uppercase match')
        |> sprintf "__AVR_%s__"
      in

      let f = function
        | { mcu; hz = Some hz } ->
            [ sprintf "-D%s" (convert_mcu mcu); sprintf "-DF_CPU=%d" hz ]
        | { mcu; hz = None } -> [ sprintf "-D%s" (convert_mcu mcu) ]
      in
      Option.value_map ~default:[] ~f config.target
    in

    List.concat
      [
        [ "# This file is generated by bavar, edit LabAvrProject instead" ];
        Compiler_args.strict_flags;
        target;
        (* C.of_build_options (build_options); *)
        C.to_headers
        @@ project.root_dir
           :: Filename.concat project.root_dir config.layout.root_dir
           :: List.map project.depends ~f:(fun p -> p.root_dir);
        [ "-I"; "/usr/avr/include" ] (* FIXME: hardcode paths *);
        C.to_includes project.includes;
        C.to_includes
        @@ get_resource_headers ~out_dir:config.layout.out_dir project.resources;
        C.to_includes @@ Array.of_list Compiler_args.default_include_headers;
      ]
end

(** Integration to VSCode C/C++ extension.  *)
module Vs_code = struct
  type t = { configurations : configuration list } [@@deriving yojson]

  and configuration = {
    name : string;
    include_path : string list; [@key "includePath"]
    compiler_path : string; [@key "compilerPath"]
    compiler_args : string list; [@key "compilerArgs"]
    defines : string list;
  }

  let workspace_folder = sprintf {|\${workspaceFolder}/%s|}

  let of_project ~(config : Project_config.t) (project : avr_project) =
    let module C = Compiler_args in
    let name =
      let hz_to_freq hz =
        if hz >= 1_000_000 then sprintf "%dmhz" (hz / 1_000_000)
        else string_of_int hz
      in

      match config.target with
      | None -> "AVR"
      | Some { mcu; hz = None } -> mcu
      | Some { mcu; hz = Some hz } -> sprintf "%s:%s" mcu (hz_to_freq hz)
    in

    {
      configurations =
        [
          {
            name;
            include_path =
              project.root_dir
              :: "/usr/avr/include" (* FIXME: unix path hardcode *)
              :: Filename.concat project.root_dir config.layout.root_dir
              :: List.map project.depends ~f:(fun p -> p.root_dir);
            compiler_path = "/usr/bin/avr-gcc";
            (* FIXME: unix path hardcode *)
            compiler_args =
              List.concat
                [
                  C.of_target config.target;
                  C.strict_flags;
                  C.to_includes (Array.of_list C.default_include_headers);
                  C.to_includes
                  @@ get_resource_headers ~out_dir:config.layout.out_dir
                       project.resources;
                ];
            defines = [];
          };
        ];
    }
end
